# 객체지향의 사실과 오해

객체지향은 흔히 현실 세계를 직접적이고 직관적으로 모델링하는 페러다임으로 설명이 된다. 여기서 핵심은 현실 속에 존재하는 사물을 모방하여 소프트웨어 내부로 옮겨오는 작업이기 때문에 객체지향 소프트웨어는 실세계의 투영이며 객체란 현실세계에 존재하는 사물에 대한 추상화라는 것임. 하지만 이런 설명은 객체지향의 기반을 이루는 철학을 설명하기에 좋지만 실용적인 관점에서 객체지향 분석, 설계를 설명하기엔 적합하지 않음.

앱을 개발하면서 실세계에 직접적으로 대응되는 사물을 찾기는 쉽지 않으며 사물을 찾는다 하더라도 개념적으로 크게 동떨어져 있음.

따라서 새로운 세계를 창조하는 것으로 접근해야함. 고객과 사용자를 만족시킬 수 있는 신세계를 창조하는것!

객체를 현실 세계의 생명체에 비유하는 것은 상태와 행위를 캡슐화하는 소프트웨어 객체의 자율성을 설명하기 효과적임. 현실의 사람들이 암묵적인 약속과 명시적인 계약을 기반으로 협력하여 목표를 달성해 나가는 과정은 객체들이 메시지를 주고받으며 목표를 달성하기 위해 협력하는 객체들의 관계를 설명하는데 적합함. 또한 실세계를 기반으로 객체를 식별하고 구현까지 이어가는 과정은 객체지향의 핵심 사상인 연결완전성(seamlessness)을 설명하는데 적합한 틀을 제공함. 이런 이유로 오해의 소지가 있음에도 객체지향을 실세계에 빗대어 설명하는 경우가 많음.

# 1. 협력하는 객체들의 공동체

## 역할, 책임, 협력

객체지향의 근본 개념은 실세계에서 사람들이 타인과 관계를 맺으며 협력하는 과정과 유사함.(카페에서 손님-캐셔-바리스타의 관계처럼) 각 객체들은 다른 객체에게 요청을 하고, 다시 다른 객체에 요청을 하며 응답을 받는 방식으로 협력하게 됨. 각 객체는 자신의 역할에 맞게 응답을 해야하고, 모든 객체들이 역할과 책임을 수행하며 협력하므로서 특정한 목표를 달성함. 여기서 중요한것은 **주어진 역할과 책임을 다하는 것**, **다른 객체와 적극적으로 협력하는 것** 임.

어플리케이션의 기능을 더 작은 책임으로 분할하고 각 책임을 적절한 역할을 수행할 수 있는 객체가 수행하게 하며 필요하다면 책임을 수행하는 도중에 다른 객체에게 도움을 요청함. 결국 시스템은 역할과 책임을 수행하는 객체로 분할되고, **시스템의 기능은 객체간의 연쇄적인 요청과 응답의 흐름으로 구성된 협력으로 구현됨.**

따라서 객체지향 설계는 적절한 객체에게 적절한 책임을 할당하는 것에서 시작되며 책임은 이 설계의 품질을 결정하는 가장 중요한 요소임. 관련성 높은 책임의 집합은 역할이 되며, 객체의 역할은 다음과 같은 특징을 지님.

- 여러 객체가 동일한 역할을 수행할 수 있음
- 역할은 대체 가능성을 의미함
- 각 객체는 책임을 수행하는 방법을 자율적으로 선택할 수 있음
- 하나의 객체가 동시에 여러 역할을 수행할 수 있음.

역할은 유연하고 재사용 가능한 협력 관계를 구축하는데 중요한 설계 요소이며, 대체가능한 역할과 책임은 다형성과도 깊이 연관되어 있음.

## 협력속에 사는 객체

객체지향 어플리케이션의 윤곽을 결정하는 것은 역할, 책임, 협력이지만 실제로 협력에 참여하는 주체는 객체임. 객체지향 어플리케이션의 아름다움을 결정하는 것이 협력이라면, 협력이 얼마나 조화를 이루는지를 결정하는것은 객체임. 결국 협력의 품질은 객체의 품질이 결정함.

협력 공동체의 일원으로서 객체는 다음과 같은 두가지지 덕목을 갖춰야 하며, 두 덕목 사이에서 균형을 이뤄야함.

- 객체는 충분히 "협력적" 이여야 함.
- 객체는 충분히 "자율적" 이여야 함.

객체는 혼자서 모든 것을 다 하는게 아니라, 다른 객체의 요청에 충실히 응답을 해야하며 필요시 요청도 보낼 수 있어야 함. 하지만 수동적인 존재가 아니며 어떤 방식으로 응답할지는 객체 스스로 판단하고 결정함. 결국 충분히 개방적인 동시에 협력에 참여하는 방식을 스스로 결정할 수 있을만큼 충분히 자율적인 객체의 공동를 설계해야함.

객체는 협력에 참여하는 과정 속에서 스스로 판단하고 결정하는 자율적인 존재가 되기 위해선 행동과 상태를 함꼐 지니고 있어야 함. 자율성은 객체의 내부와 외부를 명확하게 구분하는 것에서 나오며 사적인 부분은 자체적으로 관리하고 외부에서 간섭할 수 없도록 차단해야 하며 외부에서는 접근이 허락된 수단을 통해서만 다른 객체와 의사소통을 해야함. 즉 객체는 다른 객체가 무엇(what)을 수행하는지 알 수 있지만 어떻게(how) 수행하는지는 모름.

이렇게 데이터와 프로세스를 객체라는 하나의 틀 안에 묶어 놓는것이 전통적인 개발 방법과 가장 핵심적인 차이임. 자율적인 객체로 구성된 공동체는 유지보수가 쉽고 재사용이 용이한 시스템을 구축할 수 있는 가능성을 제시함.

현실 세계와 다르게 객체는 "메시지"라는 유일한 의사소통 수단을 가지마 메시지의 수신(receive), 발신(send)로 협력이 이루어짐. 수신자는 받은 메시지를 이해할 수 있는지 여부를 체크하고, 미리 정해진 자신만의 방법에 따라 메시지를 처리함. 이때 메시지를 처리하는 방식이 메소드(method)임. 메시지와 메소드를 분리하는 것은 객체의 협력에 참여하는 객체들 간의 자율성을 증진시키며 이런 구조는 캡슐화와 깊이 연관되어 있음.

## 객체지향의 본질

위 설명을 토대로 객체지향의 개념을 간략하게 정리하면 다음과 같음.

- 객체지향이란 시스템을 상호작용하는 **자율적인 객체들의 공동체**로 바라보고 객체를 이용해 시스템을 분할하는 방법임.
- 자율적인 객체란 상태(state)와 행위(behavior)를 함께 지니며 스스로 자기자신을 책임지는 객체를 의미함.
- 객체는 시스템의 행위를 구현하기 위해 다른 객체와 **협력**함. 각 객체는 협력 내에서 정해진 **역할**을 수행하며 역할은 관련된 **책임**의 집합임.
- 객체는 다른 객체와 협력하기 위해 메시지를 전송하고, **메시지**를 수신한 객체는 메시지를 처리하는데 적합한 **메소드**를 자율적으로 선택함.

객체지향의 인기를 주도한 것은 c++이나 java같은 class기반 프로그래밍 언어의 유행이었음. 초기 객체지향 프로그래밍 언어의 초점은 새로운 개념의 데이터 추상화를 제공하는 class라는 빌딩 블록에 맞춰져 있어서 대부분의 사람들은 원래 의도와 달리 객체지향을 클래스를 지향하는것으로 생각했으며, 시간이 갈수록 이런 경향이 강해짐. 그 결과 객체지향의 중심에 있어야할 객체로부터 사람들이 점점 멀어짐. 하지만 class는 객체지향 프로그래밍 언어의 관점에서 매우 중요한 "구성요소"이지만, 객체지향의 핵심을 이루는 중심 개념이라고 말하기엔 무리가 있음. 대표적으로 javascript 같은 경우는 prototype 기반의 객체지향 언어로, 클래스 없이 오직 객체만 존재함!

지나치게 클래스를 강조하는 프로그래밍 언어적인 관점은 객체의 캡슐화를 저해하고 클래스를 서로 강하게 결합시키며, 어플리케이션을 협력하는 객체들의 공동체가 아닌 클래스로 구성된 설계도로 보는 관점은 유연하고 확장가능한 어플리케이션의 구축을 방해함.

클래스가 아닌 객체의 관점으로 사고의 중심을 전환해야 하며, 중요한것은 "어떤 클래스가 필요한가"가 아니라 "어떤 객체들이 어떤 메시지를 주고받으며 협력하는가"이고, 클래스는 단지 객체들의 협력 관계를 코드로 옮기는 도구에 불과함. 객체지향의 핵심이 클래스라고 일컬어지는 경우가 많은데, 핵심은 **적절한 책임을 수행하는 역할 간에 유연하고 견고한 협력 관계를 구축하는 것**임. 물론 클래스도 중요하지만 협력 구조와 책임을 식별하는 것이 훨씬 중요한 것임. 객체지향의 중심에는 객체가 존재하며 클래스들의 정적인 관계가 아니라 객체들의 동적인 관계에 더 집중해야함.

**클래스의 구조와 메서드가 아니라 객체의 역할, 책임, 협력에 집중하라!**

# 2. 이상한 나라의 객체

## 객체지향과 인지능력

인간은 본능적으로 세상을 독립적이고 식별 가능한 객체의 집합으로 바라보며, 객체지향을 직관적이고 이해하기 쉬운 패러다임 이라고 말하는 이유는 이런 인간의 본능적인 인지 능력에 기초하기 때문임. 인간은 흔히 존재하는 사물 뿐만 아니라 개념적인 것들도 경계를 지을 수 있음.(오늘의 주문 내역 vs 어제의 주문 내역) 세상을 더 작은 객체로 분해하여 복잡한 세상을 더 쉽게 이해하려고 하며, 객체지향 역시 이를 따름. 그러나 객체지향과 실세계의 유사성은 이정도 까지이며, 소프트웨어상의 객체는 현실상의 객체와 전혀 다른 양상을 띄는게 일반적임. (현실에서 전등은 스스로 불을 켤 수 없음)

## 객체, 그리고 소프트웨어 나라

객체의 다양한 특성을 설명하기 위해선 객체를 **상태(state), 행동(behavior), 식별자(identifier)** 를 지닌 실체로 보는것이 가장 효과적임[Booch 2007]. 이 책에서 객체는 다음과 같이 정의함

> 객체란 식별가능한 개체 또는 사물이다. 객체는 자동차처럼 만질 수 있는 구체적인 사물일 수 있고, 시간처럼 추상적인 개념일 수도 있다. 객체는 구별 가능한 식별자, 특징적인 핻동, 변경 가능한 상태를 가진다. 소프트웨어 안에서 객체는 저장된 상태와 실행가능한 코드를 통해 구현된다.

## 상태

객체가 주변 환경과의 상호작용에 어떻게 반응하는 가는 그 시점까지 객체에 어떤 일이 발생했느냐에 따라 좌우됨. 상태를 이용하면 과거에 얽매이지 않고 현재를 기반으로 객체의 행동 방식을 이해할 수 있음. 근본적으로 세상의 복잡성을 완화하고 인지 과부하를 줄일 수 있는 중요한 개념임.

모든 객체의 상태는 단순한 값과 객체의 조합으로 표현할 수 있고, 객체를 구성하는 모든 특징을 통틀어 객체의 프로퍼티(property)라고 함. 일반적으로 프로퍼티는 정적이고 프로퍼티의 값은 동적임. 프로퍼티는 다른 객체와 값으로 구성될 수 있으며 이때 다른 객체와 의미 있게 연결되어 있다면 링크(link)라고 표현함. 객체와 객체 사이에는 링크가 존재해야 요청을 주고 받을 수 있음. 객체를 구성하는 단순한 값들은 속성(attribute)라고 함. 링크와 속성이 프로퍼티를 구성하는 것!

이 책에서 상태는 다음과 같이 정의함

> 상태는 특정 시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현함. 객체의 상태는 객체에 존재하는 정적인 프로퍼티와 동적인 프로퍼티 값으로 구성됨. 객체의 프로퍼티는 단순한 값과 다른 객체를 참조하는 링크로 구분할 수 있음.

객체는 자율적인 존재이기에 다른 객체의 상태에 직접적으로 접근할수도, 상태를 변경할 수도 없으며 스스로 상태를 책임져야함. 협력을 위해서 외부의 객체가 특정 객체의 상태를 간접적으로 변경하거나, 조회할 방법이 필요함. 여기서 객체의 행동이 나타남. 행동은 다른 객체가 객체의 상태를 변경하는것을 가능하게 함. 객체지향의 기본 사상은 상태와 상태를 조작하기 위한 행동을 하나의 단위로 묶는것임. 객체는 스스로의 행동에 의해서만 상태가 변경되는 것을 보장함으로써 객체의 자율성을 유지함.

## 행동

### 상태와 행동

객체의 상태는 저절로 변경되는게 아닌 행동에 의해서 변경됨. 이는 행동이 부수효과(side effect)를 일으킨다는 것을 의미하며 부수효과 개념을 이용하면 객체의 행동을 상태 변경의 관점에서 쉽게 기술할 수 있음. 또한 행동의 결과는 객체의 상태에 의존적임. 상태와 행동은 사이에는 다음과 같은 관계가 있음.

- 객체의 행동은 상태에 영향을 받음.
- 객체의 행동은 상태를 변경시킴.

이것은 상태라는 개념을 이용해 행동을 두가지 관점에서 서술할 수 있음을 의미함.

- 상호작용이 현재의 상태에 어떤 방식으로 의존하는가
- 상호작용이 어떻게 현재의 상태를 변경시키는가

### 협력과 행동

객체는 다른 객체와 적극적으로 상호작용 하며 "협력하는 객체들의 공동체"에 참여하기 위해 노력함. 협력하는 유일한 방법은 요청을 받고 처리하기 위해 적절히 행동하는 것임. 협력을 통해 자기 자신의 상태 변경 혹은 다른 객체의 상태 변경을 유발할 수 있음.

이 책에서 행동은 다음과 같이 정의함

> 행동이란 외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동이다. 행동의 결과로 객체는 자신의 상태를 변경하거나 다른 객체에게 메시지를 전달할 수 있다. 객체는 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 외부에 가시적이여야 한다.

### 상태 캡슐화

현실 새계의 객체와 객체지향 세계의 객체의 중요한 차이점은 객체지향 세계에서 객체는 자율적이라는 것임. 만약 음료수란 객체가 있으면, 이 객체는 스스로 양이 줄어들 수 있음. 음료수를 마신 객체는 그저 음료수 객체에 "음료수를 마셨다" 라는 메시지를 전달할 뿐이며, 양이 줄어드는 것은 음료수 객체가 하는 것임. 메시지 송신자는 이 과정에서 메시지 수신자의 상태 변경에 대해서는 전혀 알지 못함. 이것이 캡슐화를 의미함!

객체는 상태를 감추고 행동만 노출시키며, 외부에서 객체에 접근할 수 있는 유일한 방법도 행동 뿐임. 외부에서 전달된 메시지로 객체의 상태를 변경할지는 그 객체 스스로 결정하는 것임. 결국 이런 캡슐화는 객체의 자율성을 높이고, 더 똑똑해지며 유연하고 간결한 협력을 수행할 수 있게 됨.

결론적으로 상태를 잘 정의된 행동 집합 뒤로 캡슐화 하는 것은 객체의 자율성을 높이고 협력을 단순하고 유연하게 만듦.

## 식별자

객체가 식별 가능하다는 것은 객체를 서로 구별할 수 있는 특정한 프로퍼티가 객체 안에 존재한다는 뜻이 됨. 이 프로퍼티를 식별자라고 부름. 모든 객체는 식별자를 가지며 식별자를 통해 객체를 구분할 수 있음.

단순한 값같은 경우 두 인스턴스의 상태가 같으면 같은 것으로 판단함.(시간, 금액, 문자열, 숫자 등) 하지만 객체는 시간에 따라 변경되는 상태를 포함하기 때문에 타입이 같은 두 객체의 상태가 똑같아도 별개의 객체로 다뤄야 함.

하지만 객체 역시 상태와 무관하게 두 객체를 동일하거나 다르다고 판단할 수 있는 식별자를 가짐. 두 객체의 상태가 다르더라도 식별자가 같으면 같은 객체로 판단할 수 있음. 이렇게 식별자를 기반으로 객체의 동등성을 파악한느 것을 동일성(identical)이라고 함.

식별자의 개념은 상속, 캡슐화, 다형성 등 좀 더 두드러진 개념에 묻히는 경향이 있음. 하지만 객체지향의 세계는 상태가 변하지 않는 값과 변하는 객체들이 서로 조화를 이루어야 함!

## 정리

- 객체는 상태를 가지며 상태는 변경가능함.
- 객체의 상태를 변경시키는 것은 객체의 행동임.
  - 행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있음.
  - 행동의 순서가 실행 결과에 영향을 미침.
- 객체는 어떤 상태에 있더라도 유일하게 식별 가능함.

## 행동이 상태를 결정한다.

상태를 결정하고 행동을 결정하는 케이스가 많은데, 이는 설계에 나쁜 영향을 미침.

1. 상태에 초점을 맞출 경우 상태가 객체 내부로 깔끔하게 캡슐화 되지 못하고 공용 인터페이스(public interface)에 노출될 확률이 높음.
2. 객체를 협력자가 아닌 고립된 섬으로 만듦.
3. 객체의 재사용성이 저하됨.

객체는 다른 객체와 협력하기 위해 존재하며 객체의 행동은 협력에 참여하는 유일한 방법임. 따라서 객체가 적합한지 결정하는 것은 상태가 아니라 행동임!

따라서 설계시

1. 어플리케이션에 필요한 협력을 생각하고,
2. 협력에 참여하는 데 필요한 행동을 생각한 후,
3. 행동을 수행하는 객체를 선택.

행동을 결정한 후에야 행동에 필요한 정보가 무엇인지 고려하게 되며, 이때 필요한 상태가 결정됨.

협력 안에서 객체의 행동은 책임을 의미하고, 따라서 어떤 책임(Responsibility)이 필요한가를 결정하는 과정이 전체 설계를 주도해야 함.

# 3. 타입과 추상화

## 객체지향과 추상화

이 책에서 추상화는 다음과 같이 정의한다

> 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.
> 복잡성을 다루기 위해 추상화는 두 차원에서 이뤄진다[Kramer 2007].
>
> - 첫 번째 차원은 구체적인 사물들 간의 공통점은 튀하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것이다.
> - 두 번째 차원은 중요한 부분을 갖오하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것이다.
>
> 모든 경우에 추상화의 목적은 복잡성을 이해하기 쉬운 수준으로 단순화 하는 것임.

객체지향 패러다임의 중심에는 구체적이고 실제적인 객체들이 존재하지만 이들을 개별적인 단위로 고려하기엔 너무 복잡함. 사람은 본능적으로 공통점을 기반으로 객체를 그룹화 하는데, 이렇게 객체들을 묶기 위한 그릇을 개념(concept)이라고 함.

### 개념

개념을 이용하면 객체들을 여러 그룹으로 분류할 수 있어지고, 각 객체는 특정한 개념을 표현하는 그룹의 일원이 됨. 이렇게 객체에 어떤 개념을 적용하는 것이 가능해서 그룹의 일원이 될 때 객체를 그 개념의 인스턴스(instance)라고 함. 따라서 객체를 다음과 같이도 정의할 수도 있음.

> 객체란 특정한 개념을 적용할 수 있는 구체적인 사물을 의미한다. 개념이 객체에 적용됐을 때 객체를 개념의 인스턴스라고 한다.

### 개념의 세가지 관점

일반적으로 객체의 분류 장치로 개념을 이야기할 떄는 다음과 같은 세가지 관점을 함꼐 언급함[Martin 1998, Larman 2004].

- 심볼(Symbol) : 개념을 가리키는 간략한 이름이나 명칭.
- 내연(intension) : 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인할 수 있음.
- 외연(extension) : 개념에 속하는 모든 객체의 집합

심볼, 내연, 외연은 객체의 분류 방식에 대한 지침을 제공하지만, **개념을 이용해 객체를 분류할 수 있다는 사실이 더 중요함!**

### 객체를 분류하기 위한 틀

> 분류란 객체에 특정한 개념을 적용하는 작업이다. 객체에 특정한 개념을 적용하기로 결심했을 때 우리는 그 객체를 특정한 집합의 멤버로 분류하고 있는 것이다.

분류는 객체지향의 가장 중요한 개념 중 하나임. 객체가 적절히 분류된 어플리케이션은 유지보수가 용이하고 변경에 유연하게 대처할 수 있으며, 개발자 입장에서도 직관적으로 받아들일 수 있음.

결국 개념은 객체들의 복잡성을 극복하기 위한 추상화 도구이고, 추상화를 이용하여 이 세상을 제어 가능한 수준으로 단순화 할 수 있는 것임!

## 타입

> 타입은 개념과 동일하다. 따라서 타입이란 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념을 의미한다. 어떤 객체에 타입을 적용할 수 있을 때 그 객체를 타입의 인스턴스라고 한다. 타입의 인스턴스는 타입을 구성하는 외연인 객체 집합의 일원이 된다.

타입은 개념과 마찬가지로 심볼, 내연, 외연을 이용해 서술할 수 있으며 타입에 속하는 객체 역시 타입의 인스턴스 라고 함. 그러나 타입이 개념과 근본적으로 동일하더라도 컴퓨터 내부로 들어오면서 좀 더 기계적인 의미가 됨. 일반적으로 사용되던 데이터 타입과 객체지향에서의 타입은 비슷하지만 구분해서 생각하는게 좋음.

### 데이터 타입

데이터 타입은 전통적으로 사용되는 숫자, 문자열 등의 타입으로, 컴퓨터에 비트열로 저장되는 데이터를 특정 의미에 따라 분류한 것임.

- 타입은 데이터가 어떻게 사용되느냐에 관한 것임.
- 타입에 속한 데이터를 메모리에 어떻게 표현하는지는 외부로부터 철저하게 감춰짐.

이 책에서 데이터 타입은 다음과 같이 정의함

> 데이터 타입은 메모리 안에 저장된 데이터의 종류를 분류하는 데 사용되는 메모리 집합에 관한 메타데이터다. 데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는지를 결정한다.

### 객체와 타입

프로그램을 작성할때 객체를 일종의 데이터처럼 사용함. 따라서 객체를 타입에 따라 분류하고 그 타입에 이름을 붙이는 것은 결국 프로그램에서 새로운 타입을 선언하는 것과 같음.

하지만 객체는 데이터와 동일시 될 수 없음. 객체에서 중요한것은 갖고 있는 상태에 대한 데이터가 아니라 객체의 **행동**임. 상태는 행동의 결과로 초래된 부수효과를 쉽게 표현하기 위해 도입한 추상적인 개념일 뿐임. 그러나 타입의 성질은 그대로 유지되므로 객체의 타입은 다음과 같은 성질을 갖는다고 할 수 있음.

- 어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동임.
- 객체의 내부적인 표현은 외부로부터 철저하게 감춰짐.

결국 객체의 타입은 내부 표현과 아무런 상관이 없으며 **동일한 책임(행동)을 수행하는 일련의 객체는 동일한 타입에 속함**. -> 여기서 다형성과 캡슐화를 볼 수 있음.

## 타입의 계층

### 일반화/특수화 관계

두 타입이 있어서 한 타입이 다른 타입보다 좀 더 일반적으로 행동할 수 있고, 다른 타입은 특수하게 행동할 수 있음. 이 역시 "행동"을 기준으로 판단해야 함.

- 일반적인 타입은 특수한 타입이 가진 모든 행동 중 일부 행동만을 가짐
- 특수한 타입은 일반적인 타입이 가진 모든 행동을 가지며 추가적으로 자신만의 행동을 더 가짐.

따라서 일반적인 타입은 특수한 타입보다 더 적은 수의 행동을 가지지만 더 큰 크기의 외연 집합을 가짐.

### 슈퍼 타입과 서브 타입

위에서 서술한 일반적인 타입을 슈퍼타입(Supertype) 이라고 하고 특수한 타입을 서브타입(Subtype) 이라고 함.

이러한 일반화/특수화 계층은 객체지향 패러다임에서 [추상화의 두번째 차원](#객체지향과-추상화)을 잘 활용하는 예시임.

## 정적 모델

### 타입의 목적

타입을 사용하는 이유는 시간에 따라 동적으로 변하는 객체를 시간과 무관한 정적인 모습으로 다루기 위함임. 이런 관점에서 **타입은 결국 추상화**이며 정적으로 객체를 묘사할 수 있게 해줌.

### 동적 모델과 정적 모델

객체를 생각할땐 결국 두 가지 모델을 동시에 생각해야 함.

- 동적 모델(스냅샷) : 객체가 특정 시점에 구체적으로 어떤 상태를 가지는가.
- 정적 모델(타입 모델) : 객체가 가질 수 있는 모든 상태와 모든 행동을 시간에 독립적으로 표현하는 것.

객체지향 어플리케이션을 설계하고 구현하기 위해서는 객체 관점의 동적 모델과 객체를 추상화한 타입 관점의 정적 모델을 적절히 혼용해야함. 실제로 프로그래밍에서 클래스를 작성하는 시점은 시스템을 정적인 관점에서 접근하는 것이고, 런타임에서 상태 변경을 추적하는 것은 동적인 관점에서 접근하는 것임.

### 클래스

객체지향 프로그래밍 언어에서 정적인 모델은 클래스를 이용해 구현됨. 따라서 타입을 구현하는 보편적인 방법은 클래스를 이용하는 것이지만, 클래스와 타입이 동일한 것은 아님. 타입은 객체를 분류하기 위해 사용하는 개념이며 클래스는 타입을 구현할 수 있는 여러가지 구현 메커니즘 중 하나임.

**결국 중요한 것은 동적으로 변하는 객체의 '상태'와 상태를 변경하는 '행위'이며, 클래스는 타입을 구현하기 위해 프로그래밍 언어에서 제공하는 구현 메커니즘임!!**

# 4. 역할, 책임, 협력

객체의 세계에선 협력이라는 문맥이 객체의 행동 방식을 결정함. 객체지향 설계의 품질 역시 개별 객체의 품질이 아니라 협력의 품질이며, **협력이 자리잡으면 저절로 객체의 행동이 드러나고 뒤이어 적절한 객체의 상태가 결정됨.**

## 협력

객체지향의 세계는 동일한 목적을 달성하기 위해 협력하는 객체들의 공동체임. 이 협력은 각 객체가 요청하고 응답하는 과정 속에서 이루어짐. 한 객체가 요청에 응답하는 것은 협력속에서 요청에 적절히 응답할 책임이 정의되어 있기 때문임.

## 책임

어떤 객체가 어떤 요청에 대해 대답해 줄 수 있거나, 적절한 행동을 할 의무가 있으면 해당 객체가 책임을 가진다고 함.

> 객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에 할당하는 것 [Larman 2004]

책임을 어떻게 구현할 것인지는 객체와 책임이 제자리를 잡은 이후임.

### 책임의 분류

객체의 책임은 객체가 '무엇을 알고 있는가(knowing) 와 '무엇을 할수 있는가(doing)'으로 구성됨.

- 하는것(doing)
  - 객체를 생성하거나 계산을 하는 등 스스로 하는것.
  - 다른 객체의 행동을 시작시키는것.
  - 다른 객체의 활동을 제어하고 조절하는것.
- 아는것(knowing)
  - 개인적인 정보에 관해 아는 것.
  - 관련된 객체에 관해 아는 것.
  - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것.

책임은 객체의 외부에 제공해 줄 수 있는 정보(아는 것)와 외부에 제공해 줄 수 있는 서비스(하는 것)의 목록임. 결국 책임은 객체의 공용 인터페이스(public interface)를 구성함. 공용 인터페이스는 캡슐화로 이어짐.

### 책임과 메시지

객체가 다른 객체에게 주어진 책임을 수행하도록 요청을 보내는 것을 메시지 전송(message-send)라고 함. 결국 협력은 메시지를 통해 이뤄지고 송신자/수신자로 나뉨.

책임이 협력속에서 요청을 받으면 무엇을 할 수 있는지 라면, 메시지는 협력에 참여하는 두 객체 사이의 관계를 강조한 것임. 여기서 책임과 메시지는 같은 수준이 아님. 책임은 객체가 협력에 참여하기 위해 수행해야 하는 행위를 상위 수준에서 개략적으로 서술한 것임. 책임을 결정한 후 실제로 협력을 정제하면서 이를 메시지로 변환할 때는 하나의 책임이 여러 메시지로 분할되는 것이 일반적임.

객체지향 설계를 할때는 협력에 참여하기 위해 어떤 객체가 어떤 책임을 수행해야 하고 어떤 객체로부터 메시지를 수신할 것인지를 결정하는 것으로부터 시작됨. 어떤 클래스가 필요하고 어떤 메소드가 포함되어야 하는지 결정하는 것은 책임과 메시지에 대한 윤곽을 잡은 후 시작해도 늦지 않음.

## 역할

### 책임의 집합이 의미하는 것

어떤 객체가 수행하는 책임의 집합은 객체가 협력 안에서 수행하는 역할을 암시함. 역할은 재사용 가능하고 유연한 객체지항 설계를 낳는 중요한 구성요소임.

협력 안에서 역할은 해당 역할을 수행할 수 있는 어떤 객체라도 대신할 수 있음을 시사함. 역할을 대체할 수 있다는 객체는 동일한 메시지를 이해할 수 있음. 그리고 메시지는 책임을 의미함.

역할의 개념을 사용하면 유사한 협력을 추상화해서 인지 과부하를 줄일 수 있고, 객체들이 협력에 참여할 수 있기 때문에 협력이 좀 더 유연해지며, 다양한 객체들이 동일한 협력에 참여할 수 있기 떄문에 재사용성이 높아짐. 결국 역할은 객체지향 설계의 단순성(simplicity), 유언성(flexibility), 재사용성(reusability)을 뒷받침하는 핵심 개념이 됨!

### 대체 가능성

역할은 협력 안에서 객체로 대체될 수 있는 추상적인 협력자이며, 행동이 호환된다면 다른 객체에 의해 대체가 가능함. 하나의 객체는 역할이 암시하는 책임보다 더 많은 책임을 가질 수 있으며 대부분의 경우에 객체와 타입의 역할 사이에는 일반화/특수화 관계가 성립함. 역할이 일반화가 되며 객체의 타입인 특수화인 방식. 요약하면 역할의 대체 가능성은 행위 호환성을 의미하고, 행위 호환성은 동일한 책임의 수행을 의미함!

## 객체지향 설계 기법

- 책임-주도 설계(Responsibility-Driven Design) : 협력에 필요한 책임들을 식별하고 적합한 객체에게 책임을 할당하는 방식으로 어플리케이션을 설계.
- 디자인 패턴(Design Pattern) : 전문가들이 특정 문제를 해결하기 위해 이미 식별해 놓은 역할, 책임, 협력의 모음을 템플릿화 해둔 것.
- 테스트-주도 개발(Test-Driven Development) : 먼저 테스트를 작성하여 테스트를 통과하는 구체적인 코드를 추가하면서 어플리케이션을 완성해나가는 방식.

### 책임 주도 설계

1. 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악함.
2. 시스템 책임을 더 작은 책임으로 분할함.
3. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당함.
4. 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾음.
5. 해당 객체 또는 역할에게 책임을 할당하여 두 객체가 협력하게 함.

### 디자인 패턴

디자인 패턴은 반복적으로 발생하는 문제와 그 문제에 대한 해법을 쌍으로 정의하여 사용함... GOF의 "디자인 패턴"이란 책이 유명함.

### 테스트-주도 개발

테스트-주도 개발의 기본 흐름은 길패하는 테스트를 작성하고, 테스트를 통과하는 가장 간단한 코드를 작성한 후 리팩토링을 통해 중복을 제거하는 것. 이 방법으로 작동하는 깔끔한 코드를 얻을 수 있음. 객체지향에 대한 경험이 적으면 테스트를 어떤 식으로 작성해야 하는지 판단하기 힘든데, 객체가 이미 존재한다고 가정하고 객체에게 어떤 메시지를 전송할 것인지에 관해 먼저 생각하는게 좋음.

테스트-주도 개발 역시 테스트 작성이 주가 되는게 아님. 책임을 수행할 객체 또는 클라이언트가 기대하는 객체의 역할이 메시지를 수신할 때 어떤 결과를 반환하고 그 과정에서 어떤 객체와 협력할 것인지에 대한 기대를 코드의 형태로 작성하는 것임. 결국 책임-주도 설계의 기본 개념을 따라 설계를 한 뒤 테스트 코드를 작성하여야 함. 역할, 책임, 협력에 집중하고 객체지향의 원칙을 적용하려는 깊이 있는 고민과 노력을 통해서만 테스트-주도 개발의 혜택을 누릴 수 있음!!

# 5. 책임과 메시지

## 자율적인 책임

객체지향 설계의 품질을 좌우하는 것은 책임이고, 각 객체는 협력 과정에서 맡은 바 책임을 다하기 위해 자율적으로 행동해야 함. 자율적인 객체가 되기 위해선 스스로 정한 원칙에 따라 판단하고 스스로의 의지를 기반으로 행동하는 객체임. 객체가 어떤 행동을 하는 유일한 이유는 다른 객체로부터 요청을 수신했기 때문이고, 요청에 따라 행동을 수행해야 함(책임을 다하여야 함).

적절한 책임이 자율적인 객체를 낳고, 자율적인 객체들이 모여 유연하고 단순한 협력을 낳음. 따라서 협력에 참여하는 객체가 얼마나 자율적인지가 전체 어플리케이션의 품질을 결정함.

적절한 책임이란 객체에게 할당되는 책임의 수준이 자율적이란 뜻임. 예를 들면, "증언을 하라" 와 "목격한 장면을 떠올려라 -> 장면을 시간 순서대로 구성해라 -> 말로 간결하게 표현해랴"는 자율성으로 봤을때 전자가 훨씬 자율적임.

하지만 너무 추상적인 책임은 좋지 않음. 협력에 참여하는 의도를 명확하게 설명 할 수 있는 수준 안에서 추상적이여야 함. "증언하라"는 충분히 추상적이면서 의도가 있지만, "설명하라" 같은 경우는 너무 추상적임. 성급한 일반화의 오류를 범하지 말아야 하며 적절한 자율성을 가진 책임에 대하여 생각을 해봐야함.

자율적인 책임의 특징은 객체가 어떻게(how) 해야 하는가가 아니라 무엇을(what)을 해야 하는가를 설명하는 것임. 어떻게는 객체가 자율적으로 선택하는 거임.

## 메시지와 메소드

### 메시지

객체는 메시지를 전송함으로써 다른 객체에 접근함. 객체의 행동을 유발하는 행위를 가리켜 메시지-전송 이라고 하며 메시지를 전송할 때 추가적인 정보가 필요한 경우 메시지의 인자를 통해 추가 정보를 제공할 수 있음.

메시지는 메시지 이름과 인자의 두 부분으로 구성되며 메시지 전송은 수신자와 메시지 이름, 인자의 조합이 됨.

메시지를 수신한 객체는 해당 메시지를 처리할 수 있는지 확인함. 메시지를 처리할 수 있다는 이야기는 해당 메시지에 해당하는 행동을 수행해야 할 책임이 있다는 것을 의미함. 결국, 메시지의 개념은 책임의 개념과 연결됨!

요약하면 메시지는 객체들이 서로 협력하기 위해 사용하는 유일한 의사소통 수단이고, 메시지를 처리하기 위한 방법은 객체가 자율적으로 선택할 수 있기에 자연스럽게 외부와 내부가 분리됨.

### 메소드

객체는 메시지를 수신하면 먼저 해당 메시지를 처리할 수 있는지 여부를 확인함. 메시지를 처리할 수 있다면 주어진 책임을 다하기 위해 해당 메시지를 처리할 수 있는 메소드를 선택함. 결과적으로 메시지를 받은 객체는 해당 메시지에 대응되는 특정 메서드를 실행함.

### 다형성

다형성이란 서로 다른 타입에 속하는 객체들이 동일한 메시지를 수신할 경우 서로 다른 메소드를 이용해 메시지를 처리할 수 있는 메커니즘임.(= 서로 다른 유형의 객체가 동일한 메시지에 대해 서로 다르게 반응하는 것)
또한 다형성은 하나의 메시지와 하나 이상의 메서드 사이의 관계로 볼 수도 있음.

다형성은 역할, 책임, 협력과 깊은 관련이 있음. 서로 다른 객체들이 다형성을 만족한다는 것은 객체들이 동일한 책임을 공유한다는 것이며 다형성에서 중요한 것은 메시지 송신자의 관점임. 송신자 입장에선 다형적인 수신자들을 구별할 필요가 없으며 자신의 요청을 수행할 책임을 지닌다는 점에서 모두 동일함. -> 동일한 역할을 수행하는 다양한 타입의 객체와 협력할 수 있게 해줌!

기본적으로 다형성은 동일한 역할을 수행할 수 있는 객체들 사이의 대체 가능성을 의미하고, 이 대체 가능성을 이용해 설계를 유연하고 재사용 가능하게 만듦. 또한 다형성은 송신자가 수신자의 종류를 모르더라도 메시지를 전송할 수 있기 때문에 수신자의 종류를 캡슐화 한다고 볼 수도 있음.

이렇게 다형성을 이용하여 협력 구조를 유연하게 만들 수 있고, 이는 객체지향에서 큰 힘이 됨!

하지만 다형성을 이용해 확장 가능하고 재사용성이 높은 협력이 가능한 이유는 적절하게 추상화된 메시지 덕분임! 얇은 끈으로 연결된 메시지가 송신자와 수신자 사이의 결합도를 낮춰서 설계를 유연하고, 확장 가능하고, 재사용 가능하게 만들어 줌.

## 메시지를 따라라

### 객체지향의 핵심, 메시지

객체지향 어플리케이션의 중심 사상은 연쇄적으로 메시지를 전송하고 수신하는 객체들 사이의 협력 관계를 기반으로 사용자에게 유용한 기능을 제공하는 것임. 클래스 구현에 집중하거나, 데이터를 중심으로 설계하면 자율성을 저해하고 확장성이 떨어지는 결과를 낳음. 다른 것에 집중하지 말고 메세지에 집중해야 함. 메시지가 객체를 선택하게 해야하며 메시지를 중심으로 협력을 설계하여 객체를 만들어야함.

## 객체 인터페이스

### 인터페이스

일반적으로 인터페이스는 다음과 같은 세가지 특징을 지님

1. 인터페이스의 사용법을 익히기만 하면 내부 구조나 동작 방식을 몰라도 쉽게 대상을 조작하거나 의사를 전달할 수 있음.
2. 인터페이스 자체는 변경하지 않고 단순히 내부 구성이나 작동 방식만을 변경하는 것은 인터페이스 사용자에게 어떤 영향도 미치지 않음.
3. 대상이 변경되더라도 동일한 인터페이스를 제공하기만 하면 아무런 문제 없이 상호작용 가능.

협력에 참여하는 객체 역시 인터페이스를 통해 다른 객체와 상호작용 하며, 인터페이스만으로 객체들끼리 상호작용이 가능해야 함. 또한 인터페이스가 유지된다면 객체의 내부 구조나 작동 방식을 변경하거나 다른 객체로 대체하더라도 인터페이스 사용자에게 영향을 미치지 않음.

### 메시지가 인터페이스를 결정한다

객체가 상호작용 하는 유일한 방법은 메시지 전송임. 따라서 객체의 인터페이스는 객체가 수신할 수 있는 메시지의 목록으로 구성되며 어떤 메시지를 수신할 수 있는지가 객체가 제공하는 인터페이스의 모양을 형성함.

### 공용 인터페이스(public interface)

인터페이스는 사적 인터페이스(private interface)와 공용 인터페이스(public interface)로 이루어짐. 모든 인터페이스는 메시지 전송을 통해서만 접근할 수 있음. 공용 인터페이스는 메시지 송신자가 다른 객체인 것이고, 사적 인터페이스는 객체 자신이 메시지를 보낸거임. 결국 공용 인터페이스를 구성하는 것은 객체가 외부로부터 수신할 수 있는 메시지의 목록임.

## 인터페이스와 구현의 분리

객체지향적인 사고방식을 이해하기 위해선 다음의 세가지 원칙이 중요함 [Weisfeld 2008]

- 좀 더 추상적인 인터페이스 (충분히 추상화 되어야 함)
- 최소 인터페이스 (외부에서 필요하지 않은 인터페이스는 최대한 노출하지 말 것)
- 인터페이스와 구현 간에 차이가 있다는 점을 인식.

### 구현

객체지향 세계에서 내부 구조와 작동 방식을 가리키는 고유의 용어는 구현(implementation)이라고 함. 객체를 구성하지만 공용 인터페이스에 포함되지 않는 모든 것이 구현에 포함됨(상태의 표현 방식, 메시지 처리 방법인 메소드 등).

### 인터페이스와 구현의 분리 원칙

훌륭한 객체는 구현을 모른 채 인터페이스만 알면 쉽게 상호작용 할 수 있어야 함. 이는 객체를 설계할때 외부와 내부를 명확하게 분리해야 한다는 것을 뜻하며 **인터페이스와 구현의 분리(separation of interface and implementation) 원칙** 이라고 함.

인터페이스와 구현이 잘 분리되어 있다면, 객체를 변경할 일이 있을 때 쉽게 대응할 수 있으며 자율적인 객체를 만들기도 해줌.

### 캡슐화

객체의 자율성을 보존하기 위해 구현을 외부로부터 감추는 것을 캡슐화라고 함. 상태와 행위를 함께 캡슐화하여 충분히 협력적이면서 자율적인 객체를 만들 수 있음.

캡슐화는 두 가지 관점에서 사용됨

- 상태와 행위의 캡슐화
  - 객체는 스스로 자신의 상태를 관리하며 상태를 변경하고 외부에 응답할 수 있는 행동을 내부에 함께 보관함. 데이터 캡슐화라고도 함.
- 사적인 비밀의 캡슐화
  - 외부의 객체가 자신의 내부 상태를 직접 관찰하거나 제어할 수 없도록 막으며, 필요한 경우 특정한 경로만 외부에 노출함.

## 책임의 자율성이 협력의 품질을 결정한다

객체의 책임이 자율적일수록 협력이 이해하기 쉬워지고 유연하게 변경할 수 있게 되며, 전체적인 협력의 설계 품질에 영향을 미치게 됨. 그 이유는 다음과 같음

1. 자율적인 책임은 협력을 단순하게 만듦. => 세부사항을 줄이고 의도를 드러내는 하나의 문장으로 협력을 표현하는게 가능해짐
2. 자율적인 책임은 객체의 외부와 내부를 명확하게 분리함.
3. 책임이 자율적일 경우 책임을 수행하는 내부적인 방법을 변경하더라도 외부에 영향을 미치지 않음.
4. 자율적인 책임은 협력의 대상을 다양하게 선택할 수 있는 유연성을 제공함. => 설계가 유연해지고 재사용성이 높아짐.
5. 객체가 수행하는 책임들이 자율적일수록 객체의 역할이 이해하기 쉬워짐. => 책임이 자율적일수록 객체의 응집도를 높은 상태로 유지하기 쉬워짐.

> 책임이 자율적일수록 적절하게 '추상화'되며, '응집도'가 높아지고, '결합도'가 낮아지며, '캡슐화'가 증진되고, '인터페이스와 구현이 명확히 분리'되며, 설계의 '유연성'과 '재사용성'이 향상됨.

결국, 객체지향의 걍력함을 누리기 위한 출발점은 책임을 자율적으로 만드는 것임.

# 6. 객체 지도

## 기능 설계 구조 설계

소프트웨어 제품 설계에선 기능 측면의 설계와 구조 측면의 설계의 두가지 측면이 존재함. 기능은 제품이 사용자를 위해 무엇을 할 수 있는지에 초점을 맞추고, 구조는 제품의 코드가 어떠해야 하는가에 초점을 맞춤.

적절한 기능을 제공하는 것은 물론 중요하지만, 언제든지 변경사항이 생길 수 있기 때문에 변경을 수용할 수 있는 선택의 여지를 설계에 마련해 놓는것도 중요함.

전통적인 방식에는 기능에 초점을 맞춰서 기능을 중심으로 설계를 하고 구조가 기능을 따르게 했음. 객체지향은 객체의 구조에 집중하고 기능이 객체의 구조를 따르게 만듦. 시스템 기능은 더 작은 책임으로 분할되고 적절한 객체에게 분배되기 떄문에 기능이 변경되어도 객체간의 구조는 유지됨.

이것이 객체를 기반으로 책임과 역할을 식별하고 메시지를 기반으로 객체들의 협력 관계를 구축하는 이유임.

## 두 가지 재료: 기능과 구조

객체지향 세계를 구축하기 위해선 사용자에게 제공할 "기능"과 가능을 담을 안정적인 "구조"라는 재료가 필요함.

- 구조는 사용자나 이해관계자들이 도메인(domain)에 관해 생각하는 개념과 개념들 관계의 관계로 표현함.
- 기능은 사용자의 목표를 만족시키기 위해 책임을 수행하는 시스템의 행위로 표현함.

일반적으로 기능을 수집하고 표현하기 위한 기법을 **유스케이스 모델링**이라 하고 구조를 수집하고 표현하기 위한 기법을 **도메인 모델링**이라고 함.

## 안정적인 재료: 구조

### 도메인 모델

> 소프트웨어를 사용하는 사람들은 자신이 관심을 가지고 있는 특정한 분야의 문제를 해결하기 위해 소포트웨어를 사용한다. 이처럼 사용자가 프로그램을 사용하는 대상 분야를 도메인이라고 한다. [Evans 2003]

도메인 모델이란

- 사용자가 프로그램을 사용하는 대상 영역에 관한 지식을 선택적으로 단순화하고 의식적으로 구조화한 형태임.
- 소프트웨어가 목적하는 영역 내의 개념과 개념 간의 관계, 다양한 규칙이나 제약 등을 주의 깊게 추상화한것.
- 소프트웨어 개발과 관련된 이해관계자들이 도메인에 대해 생각하는 관점.

도메인 모델은 이해관계자들이 바라보는 멘탈 모델이기도 함.

- 멘탈 모델: 사람들이 자기 자신, 다른 사람, 환경, 자신이 상호작용하는 사물들에 대해 갖는 모형.

멘탈모델은 다시 사용자 모델, 디자인 모델, 시스템 이미지의 세가지로 구분됨.

- 사용자 모델: 사용자가 제품에 대해 가지고 있는 개념들의 모습.
- 디자인 모델: 설계자가 마음 속에 갖고 있는 시스템에 대한 개념화.
- 시스템 이미지: 최종 제품.

객체지향은 이렇게 도메인 모델의 세가지 측면을 가장 범용적으로 만족시킬 수 있는 거의 유일한 모델링 패러다임이며 사용자 모델, 디자인 모델, 시스템 이미지 모두가 유사한 모습을 유지하도록 만드는 것이 가능힘. 이러한 특징을 연결완전성[Waldén 1995], 또는 표현적 차이[Larman 2001] 이라고 함.

### 표현적 차이

소프트웨어 객체는 현실 객체에 대한 추상화가 아니며 은유을 기반으로 재창조 한다고 이해해야함. 그러므로 소프트웨어 객체는 현실 객체가 갖지 못한 특성과 행동을 지닐 수 있음. 하지만 소프트웨어 객체는 현실 객체를 토대로 구축되고 여기서 발생하는 의미적 거리를 표현적 차이 또는 의미적 차이 라고 함. 핵심은 은유를 통해 현실 객체와 소포트웨어 객체 사이의 차이를 최대한 줄이는것임.

하지만 대부분의 소프트웨어 도메인은 현실에 존재하지 않는 가상 세계를 대상으로 함. 따라서 소프트웨어를 만들기 위해 우리가 은유해야 할 대상은 바로 도메인 모델임. 도메인 모델을 기반으로 설계하고 구현하면 사용자가 도메인을 바라보는 관점을 그대로 코드에 반영할 수 있고 결과적으로 표현적 차이가 줄어들게 됨.

### 불안정한 기능을 담는 안정적인 도메인 모델

표현적 차이를 줄이는것 외에도 도메인 모델을 기반으로 코드를 작성하는 이유는 구조가 상대적으로 안정적이기 때문임. 도메인 모델에는 도메인의 본질적인 측면을 이해하고 있는 사용자의 관점이 녹아있으며, 이 "본질적인" 면이 구현되어 있기 때문에 사소한 변경 사항에 쉽게 대처할 수 있음.

> 결론적으로 안정적인 구조를 제공하는 도메인 모델을 기반으로 소프트웨어 구조를 설계하면 변경에 유연하게 대응할 수 있는 탄력적인 소프트웨어를 마늗ㄹ 수 있다. 도메인 모델은 여러분이 기능을 구현할 때 참조할 수 있는 궁극적인 지도임.

## 불안정한 재료: 기능

### 유스케이스

유스케이스란 사용자의 목표를 달성하기 위해 사용자와 시스템 간에 이뤄지는 상호작용의 흐름을 텍스트로 정리한 것임.

> 유스케이스는 시스템의 이해관계자들 간의 계약을 행위 중심으로 파악한다. 유스케이스는 이해관계자들 중에서 일차 액터라 불리는 행위자의 요청에 대한 시스템의 응답으로서, 다양한 조건하에 있는 시스템의 행위를 서술한다. 일차 액터는 어떤 목표를 달성하기 위해 시스템과의 상호작용을 시작한다. 시스템은 모든 이해관계자들의 요구에 응답하고 이해관계를 보호해야 한다. 특별한 요청과 관계되는 조건에 따라 서로 다른 일련의 행위 혹은 시나리오가 전개될 수 있다. 유스케이스는 이렇게 서로 다른 시나리오를 묶어준다[Cockburn 2000].G

유스케이스의 가치는 사용자들의 목표를 중심으로 시스템의 기능적인 요구사항들을 이야기 형식으로 묶을 수 있어짐.

### 유스케이스의 특성

1. 유스케이스는 사용자와 시스템 간의 상호작용을 보여주는 '텍스트'다.(다이어그램이 아님!)
2. 유스케이스는 하나의 시나리오가 아니라 여러 시나리오 들의 집합이다. 시나리오를 유스케이스의 인스턴스 라고도 한다.
3. 유스케이스는 단순한 피쳐(feature)목록과 다르다. feature는 독립적인 기능들이지만, 유스케이스는 이야기를 통해 연관된 기능들을 함꼐 묶는다.
4. 유스케이스는 사용자 인터페이스와 관련된 세부 정도를 포함하지 말아야 한다.
5. 유스케이스는 내부 설계와 관련된 정보를 포함하지 않는다.

또한 유스케이스는 설계 기법이나 객체지향 기법이 아니라 단지 사용자가 시스템을 통해 무엇을 얻을 수 있고 어떻게 상호작용할 수 있느냐에 대한 정보만 제공함.

## 재료 합치기: 기능과 구조의 통합

객체지향 패러다임은 모든것이 객체라는 사상에서 출발함. 시스템은 사용자와 만나는 경계에서 사용자의 목표를 만족시키기 위해 사용자와의 협력에 참여하는 커다란 객체임. 시스템이라는 객체 안에는 더 작은 규모의 객체가 포함될 수 있으며, 시스템이 수행하는 커다란 규모의 책임은 시스템 안에 살아가는 더 작은 크기의 객체들의 협력을 통해 구현됨. 이 시점에서 도메인 모델을 활용하여 도메인 모델에 포함된 개념을 은유하는 소프트웨어 객체를 선택해야 함.

> 객체 설계는 가끔 다음과 같이 표현되기고 한다.
> 요구사항들을 식별하고 도메인 모델을 생성한 후, 소프트웨어 클래스에 메소드들을 추가하고, 요구사항을 충족시키기 위해 객체들 간의 메시지 전송을 정의하라[Larman 2001].

유스케이스는 사용자에게 제공할 기능을 시스템의 책임으로 보게 하여 객체간의 안정적인 구조에 책임을 분배할 수 있는 출발점을 제공함. 도메인 모델은 기능을 수용하기 위해 은유할 수 있는 안정적인 구조를 제공함. 책임-주도 설계는 유스케이스 로부터 첫 번째 메시지와 사용자가 달성하려는 목표를, 도메인 모델로부터 기능을 수용할 수 있는 안정적인 구조를 제공받아 실제로 동작하는 객체들의 협력 공동체를 창조함.

책임-주도 설계 방법은 시스템의 기능을 역할과 책임을 수행하는 객체들의 협력 관계로 바라보게 함으로써 유스케이스와 도메인 모델을 통합함.

꼭 유스케이스와 도메인 모델을 활용할 필요는 없지만, **객체지향 어플리케이션을 개발하기 위해서는 사용자의 관점에서 시스템의 기능을 명시하고, 사용자와 설계자가 공유하는 안정적인 구조를 기반으로 기능을 책임으로 전환하는 체계적인 절차를 따라야 한다는 것임.**

# 후기

나중에 써야지 ㅎㅎ
