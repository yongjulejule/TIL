# 객체지향의 사실과 오해

객체지향은 흔히 현실 세계를 직접적이고 직관적으로 모델링하는 페러다임으로 설명이 된다. 여기서 핵심은 현실 속에 존재하는 사물을 모방하여 소프트웨어 내부로 옮겨오는 작업이기 때문에 객체지향 소프트웨어는 실세계의 투영이며 객체란 현실세계에 존재하는 사물에 대한 추상화라는 것임. 하지만 이런 설명은 객체지향의 기반을 이루는 철학을 설명하기에 좋지만 실용적인 관점에서 객체지향 분석, 설계를 설명하기엔 적합하지 않음.

앱을 개발하면서 실세계에 직접적으로 대응되는 사물을 찾기는 쉽지 않으며 사물을 찾는다 하더라도 개념적으로 크게 동떨어져 있음.

따라서 새로운 세계를 창조하는 것으로 접근해야함. 고객과 사용자를 만족시킬 수 있는 신세계를 창조하는것!

객체를 현실 세계의 생명체에 비유하는 것은 상태와 행위를 캡슐화하는 소프트웨어 객체의 자율성을 설명하기 효과적임. 현실의 사람들이 암묵적인 약속과 명시적인 계약을 기반으로 협력하여 목표를 달성해 나가는 과정은 객체들이 메시지를 주고받으며 목표를 달성하기 위해 협력하는 객체들의 관계를 설명하는데 적합함. 또한 실세계를 기반으로 객체를 식별하고 구현까지 이어가는 과정은 객체지향의 핵심 사상인 연결완전성(seamlessness)을 설명하는데 적합한 틀을 제공함. 이런 이유로 오해의 소지가 있음에도 객체지향을 실세계에 빗대어 설명하는 경우가 많음.

# 1. 협력하는 객체들의 공동체

## 역할, 책임, 협력

객체지향의 근본 개념은 실세계에서 사람들이 타인과 관계를 맺으며 협력하는 과정과 유사함.(카페에서 손님-캐셔-바리스타의 관계처럼) 각 객체들은 다른 객체에게 요청을 하고, 다시 다른 객체에 요청을 하며 응답을 받는 방식으로 협력하게 됨. 각 객체는 자신의 역할에 맞게 응답을 해야하고, 모든 객체들이 역할과 책임을 수행하며 협력하므로서 특정한 목표를 달성함. 여기서 중요한것은 **주어진 역할과 책임을 다하는 것**, **다른 객체와 적극적으로 협력하는 것** 임.

어플리케이션의 기능을 더 작은 책임으로 분할하고 각 책임을 적절한 역할을 수행할 수 있는 객체가 수행하게 하며 필요하다면 책임을 수행하는 도중에 다른 객체에게 도움을 요청함. 결국 시스템은 역할과 책임을 수행하는 객체로 분할되고, **시스템의 기능은 객체간의 연쇄적인 요청과 응답의 흐름으로 구성된 협력으로 구현됨.**

따라서 객체지향 설계는 적절한 객체에게 적절한 책임을 할당하는 것에서 시작되며 책임은 이 설계의 품질을 결정하는 가장 중요한 요소임. 관련성 높은 책임의 집합은 역할이 되며, 객체의 역할은 다음과 같은 특징을 지님.

- 여러 객체가 동일한 역할을 수행할 수 있음
- 역할은 대체 가능성을 의미함
- 각 객체는 책임을 수행하는 방법을 자율적으로 선택할 수 있음
- 하나의 객체가 동시에 여러 역할을 수행할 수 있음.

역할은 유연하고 재사용 가능한 협력 관계를 구축하는데 중요한 설계 요소이며, 대체가능한 역할과 책임은 다형성과도 깊이 연관되어 있음.

## 협력속에 사는 객체

객체지향 어플리케이션의 윤곽을 결정하는 것은 역할, 책임, 협력이지만 실제로 협력에 참여하는 주체는 객체임. 객체지향 어플리케이션의 아름다움을 결정하는 것이 협력이라면, 협력이 얼마나 조화를 이루는지를 결정하는것은 객체임. 결국 협력의 품질은 객체의 품질이 결정함.

협력 공동체의 일원으로서 객체는 다음과 같은 두가지지 덕목을 갖춰야 하며, 두 덕목 사이에서 균형을 이뤄야함.

- 객체는 충분히 "협력적" 이여야 함.
- 객체는 충분히 "자율적" 이여야 함.

객체는 혼자서 모든 것을 다 하는게 아니라, 다른 객체의 요청에 충실히 응답을 해야하며 필요시 요청도 보낼 수 있어야 함. 하지만 수동적인 존재가 아니며 어떤 방식으로 응답할지는 객체 스스로 판단하고 결정함. 결국 충분히 개방적인 동시에 협력에 참여하는 방식을 스스로 결정할 수 있을만큼 충분히 자율적인 객체의 공동를 설계해야함.

객체는 협력에 참여하는 과정 속에서 스스로 판단하고 결정하는 자율적인 존재가 되기 위해선 행동과 상태를 함꼐 지니고 있어야 함. 자율성은 객체의 내부와 외부를 명확하게 구분하는 것에서 나오며 사적인 부분은 자체적으로 관리하고 외부에서 간섭할 수 없도록 차단해야 하며 외부에서는 접근이 허락된 수단을 통해서만 다른 객체와 의사소통을 해야함. 즉 객체는 다른 객체가 무엇(what)을 수행하는지 알 수 있지만 어떻게(how) 수행하는지는 모름.

이렇게 데이터와 프로세스를 객체라는 하나의 틀 안에 묶어 놓는것이 전통적인 개발 방법과 가장 핵심적인 차이임. 자율적인 객체로 구성된 공동체는 유지보수가 쉽고 재사용이 용이한 시스템을 구축할 수 있는 가능성을 제시함.

현실 세계와 다르게 객체는 "메시지"라는 유일한 의사소통 수단을 가지마 메시지의 수신(receive), 발신(send)로 협력이 이루어짐. 수신자는 받은 메시지를 이해할 수 있는지 여부를 체크하고, 미리 정해진 자신만의 방법에 따라 메시지를 처리함. 이때 메시지를 처리하는 방식이 메소드(method)임. 메시지와 메소드를 분리하는 것은 객체의 협력에 참여하는 객체들 간의 자율성을 증진시키며 이런 구조는 캡슐화와 깊이 연관되어 있음.

## 객체지향의 본질

위 설명을 토대로 객체지향의 개념을 간략하게 정리하면 다음과 같음.

- 객체지향이란 시스템을 상호작용하는 **자율적인 객체들의 공동체**로 바라보고 객체를 이용해 시스템을 분할하는 방법임.
- 자율적인 객체란 상태(state)와 행위(behavior)를 함께 지니며 스스로 자기자신을 책임지는 객체를 의미함.
- 객체는 시스템의 행위를 구현하기 위해 다른 객체와 **협력**함. 각 객체는 협력 내에서 정해진 **역할**을 수행하며 역할은 관련된 **책임**의 집합임.
- 객체는 다른 객체와 협력하기 위해 메시지를 전송하고, **메시지**를 수신한 객체는 메시지를 처리하는데 적합한 **메소드**를 자율적으로 선택함.

객체지향의 인기를 주도한 것은 c++이나 java같은 class기반 프로그래밍 언어의 유행이었음. 초기 객체지향 프로그래밍 언어의 초점은 새로운 개념의 데이터 추상화를 제공하는 class라는 빌딩 블록에 맞춰져 있어서 대부분의 사람들은 원래 의도와 달리 객체지향을 클래스를 지향하는것으로 생각했으며, 시간이 갈수록 이런 경향이 강해짐. 그 결과 객체지향의 중심에 있어야할 객체로부터 사람들이 점점 멀어짐. 하지만 class는 객체지향 프로그래밍 언어의 관점에서 매우 중요한 "구성요소"이지만, 객체지향의 핵심을 이루는 중심 개념이라고 말하기엔 무리가 있음. 대표적으로 javascript 같은 경우는 prototype 기반의 객체지향 언어로, 클래스 없이 오직 객체만 존재함!

지나치게 클래스를 강조하는 프로그래밍 언어적인 관점은 객체의 캡슐화를 저해하고 클래스를 서로 강하게 결합시키며, 어플리케이션을 협력하는 객체들의 공동체가 아닌 클래스로 구성된 설계도로 보는 관점은 유연하고 확장가능한 어플리케이션의 구축을 방해함.

클래스가 아닌 객체의 관점으로 사고의 중심을 전환해야 하며, 중요한것은 "어떤 클래스가 필요한가"가 아니라 "어떤 객체들이 어떤 메시지를 주고받으며 협력하는가"이고, 클래스는 단지 객체들의 협력 관계를 코드로 옮기는 도구에 불과함. 객체지향의 핵심이 클래스라고 일컬어지는 경우가 많은데, 핵심은 **적절한 책임을 수행하는 역할 간에 유연하고 견고한 협력 관계를 구축하는 것**임. 물론 클래스도 중요하지만 협력 구조와 책임을 식별하는 것이 훨씬 중요한 것임. 객체지향의 중심에는 객체가 존재하며 클래스들의 정적인 관계가 아니라 객체들의 동적인 관계에 더 집중해야함.

**클래스의 구조와 메서드가 아니라 객체의 역할, 책임, 협력에 집중하라!**

# 2. 이상한 나라의 객체

## 객체지향과 인지능력

인간은 본능적으로 세상을 독립적이고 식별 가능한 객체의 집합으로 바라보며, 객체지향을 직관적이고 이해하기 쉬운 패러다임 이라고 말하는 이유는 이런 인간의 본능적인 인지 능력에 기초하기 때문임. 인간은 흔히 존재하는 사물 뿐만 아니라 개념적인 것들도 경계를 지을 수 있음.(오늘의 주문 내역 vs 어제의 주문 내역) 세상을 더 작은 객체로 분해하여 복잡한 세상을 더 쉽게 이해하려고 하며, 객체지향 역시 이를 따름. 그러나 객체지향과 실세계의 유사성은 이정도 까지이며, 소프트웨어상의 객체는 현실상의 객체와 전혀 다른 양상을 띄는게 일반적임. (현실에서 전등은 스스로 불을 켤 수 없음)

## 객체, 그리고 소프트웨어 나라

객체의 다양한 특성을 설명하기 위해선 객체를 **상태(state), 행동(behavior), 식별자(identifier)**를 지닌 실체로 보는것이 가장 효과적임[Booch 2007]. 이 책에서 객체는 다음과 같이 정의함

> 객체란 식별가능한 개체 또는 사물이다. 객체는 자동차처럼 만질 수 있는 구체적인 사물일 수 있고, 시간처럼 추상적인 개념일 수도 있다. 객체는 구별 가능한 식별자, 특징적인 핻동, 변경 가능한 상태를 가진다. 소프트웨어 안에서 객체는 저장된 상태와 실행가능한 코드를 통해 구현된다.

## 상태

객체가 주변 환경과의 상호작용에 어떻게 반응하는 가는 그 시점까지 객체에 어떤 일이 발생했느냐에 따라 좌우됨. 상태를 이용하면 과거에 얽매이지 않고 현재를 기반으로 객체의 행동 방식을 이해할 수 있음. 근본적으로 세상의 복잡성을 완화하고 인지 과부하를 줄일 수 있는 중요한 개념임.

모든 객체의 상태는 단순한 값과 객체의 조합으로 표현할 수 있고, 객체를 구성하는 모든 특징을 통틀어 객체의 프로퍼티(property)라고 함. 일반적으로 프로퍼티는 정적이고 프로퍼티의 값은 동적임. 프로퍼티는 다른 객체와 값으로 구성될 수 있으며 이때 다른 객체와 의미 있게 연결되어 있다면 링크(link)라고 표현함. 객체와 객체 사이에는 링크가 존재해야 요청을 주고 받을 수 있음. 객체를 구성하는 단순한 값들은 속성(attribute)라고 함. 링크와 속성이 프로퍼티를 구성하는 것!

이 책에서 상태는 다음과 같이 정의함

> 상태는 특정 시점에 객체가 가지고 있는 정보의 집합으로 객체의 구조적 특징을 표현함. 객체의 상태는 객체에 존재하는 정적인 프로퍼티와 동적인 프로퍼티 값으로 구성됨. 객체의 프로퍼티는 단순한 값과 다른 객체를 참조하는 링크로 구분할 수 있음.

객체는 자율적인 존재이기에 다른 객체의 상태에 직접적으로 접근할수도, 상태를 변경할 수도 없으며 스스로 상태를 책임져야함. 협력을 위해서 외부의 객체가 특정 객체의 상태를 간접적으로 변경하거나, 조회할 방법이 필요함. 여기서 객체의 행동이 나타남. 행동은 다른 객체가 객체의 상태를 변경하는것을 가능하게 함. 객체지향의 기본 사상은 상태와 상태를 조작하기 위한 행동을 하나의 단위로 묶는것임. 객체는 스스로의 행동에 의해서만 상태가 변경되는 것을 보장함으로써 객체의 자율성을 유지함.

## 행동

### 상태와 행동

객체의 상태는 저절로 변경되는게 아닌 행동에 의해서 변경됨. 이는 행동이 부수효과(side effect)를 일으킨다는 것을 의미하며 부수효과 개념을 이용하면 객체의 행동을 상태 변경의 관점에서 쉽게 기술할 수 있음. 또한 행동의 결과는 객체의 상태에 의존적임. 상태와 행동은 사이에는 다음과 같은 관계가 있음.

- 객체의 행동은 상태에 영향을 받음.
- 객체의 행동은 상태를 변경시킴.

이것은 상태라는 개념을 이용해 행동을 두가지 관점에서 서술할 수 있음을 의미함.

- 상호작용이 현재의 상태에 어떤 방식으로 의존하는가
- 상호작용이 어떻게 현재의 상태를 변경시키는가

### 협력과 행동

객체는 다른 객체와 적극적으로 상호작용 하며 "협력하는 객체들의 공동체"에 참여하기 위해 노력함. 협력하는 유일한 방법은 요청을 받고 처리하기 위해 적절히 행동하는 것임. 협력을 통해 자기 자신의 상태 변경 혹은 다른 객체의 상태 변경을 유발할 수 있음.

이 책에서 행동은 다음과 같이 정의함

> 행동이란 외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동이다. 행동의 결과로 객체는 자신의 상태를 변경하거나 다른 객체에게 메시지를 전달할 수 있다. 객체는 행동을 통해 다른 객체와의 협력에 참여하므로 행동은 외부에 가시적이여야 한다.

### 상태 캡슐화

현실 새계의 객체와 객체지향 세계의 객체의 중요한 차이점은 객체지향 세계에서 객체는 자율적이라는 것임. 만약 음료수란 객체가 있으면, 이 객체는 스스로 양이 줄어들 수 있음. 음료수를 마신 객체는 그저 음료수 객체에 "음료수를 마셨다" 라는 메시지를 전달할 뿐이며, 양이 줄어드는 것은 음료수 객체가 하는 것임. 메시지 송신자는 이 과정에서 메시지 수신자의 상태 변경에 대해서는 전혀 알지 못함. 이것이 캡슐화를 의미함!

객체는 상태를 감추고 행동만 노출시키며, 외부에서 객체에 접근할 수 있는 유일한 방법도 행동 뿐임. 외부에서 전달된 메시지로 객체의 상태를 변경할지는 그 객체 스스로 결정하는 것임. 결국 이런 캡슐화는 객체의 자율성을 높이고, 더 똑똑해지며 유연하고 간결한 협력을 수행할 수 있게 됨.

결론적으로 상태를 잘 정의된 행동 집합 뒤로 캡슐화 하는 것은 객체의 자율성을 높이고 협력을 단순하고 유연하게 만듦.

## 식별자

객체가 식별 가능하다는 것은 객체를 서로 구별할 수 있는 특정한 프로퍼티가 객체 안에 존재한다는 뜻이 됨. 이 프로퍼티를 식별자라고 부름. 모든 객체는 식별자를 가지며 식별자를 통해 객체를 구분할 수 있음.

단순한 값같은 경우 두 인스턴스의 상태가 같으면 같은 것으로 판단함.(시간, 금액, 문자열, 숫자 등) 하지만 객체는 시간에 따라 변경되는 상태를 포함하기 때문에 타입이 같은 두 객체의 상태가 똑같아도 별개의 객체로 다뤄야 함.

하지만 객체 역시 상태와 무관하게 두 객체를 동일하거나 다르다고 판단할 수 있는 식별자를 가짐. 두 객체의 상태가 다르더라도 식별자가 같으면 같은 객체로 판단할 수 있음. 이렇게 식별자를 기반으로 객체의 동등성을 파악한느 것을 동일성(identical)이라고 함.

식별자의 개념은 상속, 캡슐화, 다형성 등 좀 더 두드러진 개념에 묻히는 경향이 있음. 하지만 객체지향의 세계는 상태가 변하지 않는 값과 변하는 객체들이 서로 조화를 이루어야 함!

## 정리

- 객체는 상태를 가지며 상태는 변경가능함.
- 객체의 상태를 변경시키는 것은 객체의 행동임.
  - 행동의 결과는 상태에 의존적이며 상태를 이용해 서술할 수 있음.
  - 행동의 순서가 실행 결과에 영향을 미침.
- 객체는 어떤 상태에 있더라도 유일하게 식별 가능함.

## 행동이 상태를 결정한다.

상태를 결정하고 행동을 결정하는 케이스가 많은데, 이는 설계에 나쁜 영향을 미침.

1. 상태에 초점을 맞출 경우 상태가 객체 내부로 깔끔하게 캡슐화 되지 못하고 공용 인터페이스(public interface)에 노출될 확률이 높음.
2. 객체를 협력자가 아닌 고립된 섬으로 만듦.
3. 객체의 재사용성이 저하됨.

객체는 다른 객체와 협력하기 위해 존재하며 객체의 행동은 협력에 참여하는 유일한 방법임. 따라서 객체가 적합한지 결정하는 것은 상태가 아니라 행동임!

따라서 설계시

1. 어플리케이션에 필요한 협력을 생각하고,
2. 협력에 참여하는 데 필요한 행동을 생각한 후,
3. 행동을 수행하는 객체를 선택.

행동을 결정한 후에야 행동에 필요한 정보가 무엇인지 고려하게 되며, 이때 필요한 상태가 결정됨.

협력 안에서 객체의 행동은 책임을 의미하고, 따라서 어떤 책임(Responsibility)이 필요한가를 결정하는 과정이 전체 설계를 주도해야 함.

# 3. 타입과 추상화

## 객체지향과 추상화

이 책에서 추상화는 다음과 같이 정의한다

> 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.
> 복잡성을 다루기 위해 추상화는 두 차원에서 이뤄진다[Kramer 2007].
>
> - 첫 번째 차원은 구체적인 사물들 간의 공통점은 튀하고 차이점은 버리는 일반화를 통해 단순하게 만드는 것이다.
> - 두 번째 차원은 중요한 부분을 갖오하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만드는 것이다.
>
> 모든 경우에 추상화의 목적은 복잡성을 이해하기 쉬운 수준으로 단순화 하는 것임.

객체지향 패러다임의 중심에는 구체적이고 실제적인 객체들이 존재하지만 이들을 개별적인 단위로 고려하기엔 너무 복잡함. 사람은 본능적으로 공통점을 기반으로 객체를 그룹화 하는데, 이렇게 객체들을 묶기 위한 그릇을 개념(concept)이라고 함.

### 개념

개념을 이용하면 객체들을 여러 그룹으로 분류할 수 있어지고, 각 객체는 특정한 개념을 표현하는 그룹의 일원이 됨. 이렇게 객체에 어떤 개념을 적용하는 것이 가능해서 그룹의 일원이 될 때 객체를 그 개념의 인스턴스(instance)라고 함. 따라서 객체를 다음과 같이도 정의할 수도 있음.

> 객체란 특정한 개념을 적용할 수 있는 구체적인 사물을 의미한다. 개념이 객체에 적용됐을 때 객체를 개념의 인스턴스라고 한다.

### 개념의 세가지 관점

일반적으로 객체의 분류 장치로 개념을 이야기할 떄는 다음과 같은 세가지 관점을 함꼐 언급함[Martin 1998, Larman 2004].

- 심볼(Symbol) : 개념을 가리키는 간략한 이름이나 명칭.
- 내연(intension) : 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인할 수 있음.
- 외연(extension) : 개념에 속하는 모든 객체의 집합

심볼, 내연, 외연은 객체의 분류 방식에 대한 지침을 제공하지만, **개념을 이용해 객체를 분류할 수 있다는 사실이 더 중요함!**

### 객체를 분류하기 위한 틀

> 분류란 객체에 특정한 개념을 적용하는 작업이다. 객체에 특정한 개념을 적용하기로 결심했을 때 우리는 그 객체를 특정한 집합의 멤버로 분류하고 있는 것이다.

분류는 객체지향의 가장 중요한 개념 중 하나임. 객체가 적절히 분류된 어플리케이션은 유지보수가 용이하고 변경에 유연하게 대처할 수 있으며, 개발자 입장에서도 직관적으로 받아들일 수 있음.

결국 개념은 객체들의 복잡성을 극복하기 위한 추상화 도구이고, 추상화를 이용하여 이 세상을 제어 가능한 수준으로 단순화 할 수 있는 것임!

## 타입

> 타입은 개념과 동일하다. 따라서 타입이란 우리가 인식하고 있는 다양한 사물이나 객체에 적용할 수 있는 아이디어나 관념을 의미한다. 어떤 객체에 타입을 적용할 수 있을 때 그 객체를 타입의 인스턴스라고 한다. 타입의 인스턴스는 타입을 구성하는 외연인 객체 집합의 일원이 된다.

타입은 개념과 마찬가지로 심볼, 내연, 외연을 이용해 서술할 수 있으며 타입에 속하는 객체 역시 타입의 인스턴스 라고 함. 그러나 타입이 개념과 근본적으로 동일하더라도 컴퓨터 내부로 들어오면서 좀 더 기계적인 의미가 됨. 일반적으로 사용되던 데이터 타입과 객체지향에서의 타입은 비슷하지만 구분해서 생각하는게 좋음.

### 데이터 타입

데이터 타입은 전통적으로 사용되는 숫자, 문자열 등의 타입으로, 컴퓨터에 비트열로 저장되는 데이터를 특정 의미에 따라 분류한 것임.

- 타입은 데이터가 어떻게 사용되느냐에 관한 것임.
- 타입에 속한 데이터를 메모리에 어떻게 표현하는지는 외부로부터 철저하게 감춰짐.

이 책에서 데이터 타입은 다음과 같이 정의함

> 데이터 타입은 메모리 안에 저장된 데이터의 종류를 분류하는 데 사용되는 메모리 집합에 관한 메타데이터다. 데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는지를 결정한다.

### 객체와 타입

프로그램을 작성할때 객체를 일종의 데이터처럼 사용함. 따라서 객체를 타입에 따라 분류하고 그 타입에 이름을 붙이는 것은 결국 프로그램에서 새로운 타입을 선언하는 것과 같음.

하지만 객체는 데이터와 동일시 될 수 없음. 객체에서 중요한것은 갖고 있는 상태에 대한 데이터가 아니라 객체의 **행동**임. 상태는 행동의 결과로 초래된 부수효과를 쉽게 표현하기 위해 도입한 추상적인 개념일 뿐임. 그러나 타입의 성질은 그대로 유지되므로 객체의 타입은 다음과 같은 성질을 갖는다고 할 수 있음.

- 어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동임.
- 객체의 내부적인 표현은 외부로부터 철저하게 감춰짐.

결국 객체의 타입은 내부 표현과 아무런 상관이 없으며 **동일한 책임(행동)을 수행하는 일련의 객체는 동일한 타입에 속함**. -> 여기서 다형성과 캡슐화를 볼 수 있음.

## 타입의 계층

### 일반화/특수화 관계

두 타입이 있어서 한 타입이 다른 타입보다 좀 더 일반적으로 행동할 수 있고, 다른 타입은 특수하게 행동할 수 있음. 이 역시 "행동"을 기준으로 판단해야 함.

- 일반적인 타입은 특수한 타입이 가진 모든 행동 중 일부 행동만을 가짐
- 특수한 타입은 일반적인 타입이 가진 모든 행동을 가지며 추가적으로 자신만의 행동을 더 가짐.

따라서 일반적인 타입은 특수한 타입보다 더 적은 수의 행동을 가지지만 더 큰 크기의 외연 집합을 가짐.

### 슈퍼 타입과 서브 타입

위에서 서술한 일반적인 타입을 슈퍼타입(Supertype) 이라고 하고 특수한 타입을 서브타입(Subtype) 이라고 함.

이러한 일반화/특수화 계층은 객체지향 패러다임에서 [추상화의 두번째 차원](#객체지향과-추상화)을 잘 활용하는 예시임.

## 정적 모델

### 타입의 목적

타입을 사용하는 이유는 시간에 따라 동적으로 변하는 객체를 시간과 무관한 정적인 모습으로 다루기 위함임. 이런 관점에서 **타입은 결국 추상화**이며 정적으로 객체를 묘사할 수 있게 해줌.

### 동적 모델과 정적 모델

객체를 생각할땐 결국 두 가지 모델을 동시에 생각해야 함.

- 동적 모델(스냅샷) : 객체가 특정 시점에 구체적으로 어떤 상태를 가지는가.
- 정적 모델(타입 모델) : 객체가 가질 수 있는 모든 상태와 모든 행동을 시간에 독립적으로 표현하는 것.

객체지향 어플리케이션을 설계하고 구현하기 위해서는 객체 관점의 동적 모델과 객체를 추상화한 타입 관점의 정적 모델을 적절히 혼용해야함. 실제로 프로그래밍에서 클래스를 작성하는 시점은 시스템을 정적인 관점에서 접근하는 것이고, 런타임에서 상태 변경을 추적하는 것은 동적인 관점에서 접근하는 것임.

### 클래스

객체지향 프로그래밍 언어에서 정적인 모델은 클래스를 이용해 구현됨. 따라서 타입을 구현하는 보편적인 방법은 클래스를 이용하는 것이지만, 클래스와 타입이 동일한 것은 아님. 타입은 객체를 분류하기 위해 사용하는 개념이며 클래스는 타입을 구현할 수 있는 여러가지 구현 메커니즘 중 하나임.

**결국 중요한 것은 동적으로 변하는 객체의 '상태'와 상태를 변경하는 '행위'이며, 클래스는 타입을 구현하기 위해 프로그래밍 언어에서 제공하는 구현 메커니즘임!!**

# 4. 역할, 책임, 협력

객체의 세계에선 협력이라는 문맥이 객체의 행동 방식을 결정함. 객체지향 설계의 품질 역시 개별 객체의 품질이 아니라 협력의 품질이며, **협력이 자리잡으면 저절로 객체의 행동이 드러나고 뒤이어 적절한 객체의 상태가 결정됨.**

## 협력

객체지향의 세계는 동일한 목적을 달성하기 위해 협력하는 객체들의 공동체임. 이 협력은 각 객체가 요청하고 응답하는 과정 속에서 이루어짐. 한 객체가

---

객체지향은 객체중심... 클래스 이런거 아님... 객체는 행동을 하고 상태를 가짐... 행동에서 역할과 책임이 나오고... 상태를 기반으로 작동하는...

거대한 시스템 객체가 있고 그 안에서 객체들이 협력해서 어플리케이션을 이루는 그런 구조...

중요한건 협력... 협력... 객체를 먼저 짜는게 아니라... 협력을 해야함... 객체들의 요청과 응답을 통하여 협력을 하는데... 그 협력 구조를 먼저 짜고, 거기에 객체를 대입하는 느낌.

이때 표면적으로 드러나서 협력하는게 메소드고, 이는 추상화하여 간결하게 표현하는게 좋음... 이런게 공용 인터페이스에 들어가 있고 세부 사항은 내부에서 구현하는게 캡슐화...

또한 추상적인 메소드 내부에서 각 객체들이 협력을 이뤄내는 방식은 다 다를 수 있지만, 응답만 합리적이면 됨... 따라서 같은 메소드에 대하여 다른 방식으로 작동하는게 다형성...

뭐 대충 이런 이야기임.
